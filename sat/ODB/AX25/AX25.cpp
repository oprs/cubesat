/**
 *  File: AX25.cpp
 *  27/04/2015
 */


#include "AX25.h"
#include "CRC16_CCITT.h"
#include "bitStuffing.h"


#define N_FLAG_BEGIN    4
#define N_FLAG_END      4


using namespace qb50;


/**
 * tab_LSB_First
 *
 * Generated by PHP script on website: http://phptester.net/
 *
 ******************************************************************************
    <?php
        echo "<pre>static const uint8_t tab_LSB_First[]={<br />    ";
        for( $i=0x0 ; $i<=0xff; $i++)
        {
            $val=(
                (($i & 0x80) >> 7) +
                (($i & 0x40) >> 5) +
                (($i & 0x20) >> 3) +
                (($i & 0x10) >> 1) +
                (($i & 0x08) << 1) +
                (($i & 0x04) << 3) +
                (($i & 0x02) << 5) +
                (($i & 0x01) << 7)
            ) & 0xff;
            echo '0x'.(strlen(dechex($val))<2 ? '0'.dechex($val) : dechex($val));
            if($i < 0xff)
            {
                echo  ", ";
                if( !(($i+1) % 16))
                    echo '<br />    ';
            }
        }
        echo "<br />};</pre>";
 ******************************************************************************
 *
 *  @author     Jérôme Skoda    <jerome.skoda@hotmail.fr>
 *  @version    1.0             (30/04/2015)
 *
 */
static const uint8_t tab_LSB_First[]={
    0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
};


/**
 *  StringToAddressAX25
 *
 *  Change string to address with AX25 protocol.
 *
 *  If character in string is not a capital letter and not a number, it's change to space character
 *  All character is left shift. The string output has length of 6 characters.
 *
 *  Example: "AbC3"       (4  bytes) is convert to "A C3  "<<1 (6 bytes)
 *           "GRâ€ liçlà" (10 bytes) is convert to "GR    "<<1 (6 bytes)
 *
 *  @author     Jérôme Skoda    <jerome.skoda@hotmail.fr>
 *  @version    1.1             (22/04/2015)
 */
void StringToAddressAX25(uint8_t *dst, uint8_t *adress)
{
    // Adresse 6 caractére maximum
    for(int n=0; n < 6; ++n)
    {
        // [A-Z0-9] sinon ' '
        if(((((uint8_t*)adress)[n] >= 'A') && ((uint8_t*)adress)[n] <= 'Z') || ((((uint8_t*)adress)[n] >= '0') && ((uint8_t*)adress)[n] <= '9'))
        {
            // Ecriture de la [A-Z0-9] << 1
            ((uint8_t*)dst)[n]= ((uint8_t*)adress)[n] << 1;
        }
        else
        {
            // Ecriture ' ' << 1
            ((uint8_t*)dst)[n]= ' ' << 1;
        }
    }
}


/**
 *  writeHeader
 *
 *  Write header section 16 bytes with AX25 protocol
 *  ╔══════════════════╦══════════════════╦════════╦═════════════╦═════════╦═════════════════════╗
 *  ║ Destination name ║ destination SSID ║ Source ║ Source SSID ║ Control ║ Protocol identifier ║
 *  ╠══════════════════╬══════════════════╬════════╬═════════════╬═════════╬═════════════════════╣
 *  ║ bytes 1-6        ║ 7                ║ 8-13   ║ 14          ║ 15      ║ 16                  ║
 *  ╚══════════════════╩══════════════════╩════════╩═════════════╩═════════╩═════════════════════╝
 *
 *  @author     Jérôme Skoda    <jerome.skoda@hotmail.fr>
 *  @version    1.3             (24/04/2015)
 */
size_t PacketAX25::writeHeader(uint8_t  *dst)
{
    // Write address destination octet 0-5
    StringToAddressAX25(dst, destination.address);

    // Write CCR/SSID octet 6
    ((uint8_t*)dst)[6]=  (
                          // CCR 7-5 bits
                          ((destination.CCR  & 0x07) << 5) +
                          // SSID 4-1 bits
                          ((destination.SSID & 0x0F) << 1)
                          // '0' last bit required
                         ) & 0xFE;

    // Write address destination octet 7-13
    StringToAddressAX25(&(((uint8_t*)dst)[7]), source.address);

    // Write CCR/SSID octet 14
    ((uint8_t*)dst)[13]= (
                          // CCR 7-5 bits
                          ((source.CCR  & 0x07) << 5) +
                          // SSID 4-1 bits
                          ((source.SSID & 0x0F) << 1)
                          // '1' last bit of address section
                         ) | 0x01;

    // Write control field, look AX25_control_Mode enumerate
    ((uint8_t*)dst)[14]= controle;

    // Write control field, look AX25_PID_Mode enumerate
    ((uint8_t*)dst)[15]= PID;

    return (size_t)16;
}


/**
 *  writeContent
 *
 *  Write content format with AX25 protocol
 * ╔══════════╦══════════╦═════════╦════════╦════════════════════╦═════════╦══════════╗
 * ║   Flag   ║ Address  ║ Control ║  PID   ║    Information     ║   FCS   ║   Flag   ║
 * ╠══════════╬══════════╬═════════╬════════╬════════════════════╬═════════╬══════════╣
 * ║ 01111110 ║ 112 Bits ║ 8 Bits  ║ 8 Bits ║ N*8 Bits (32-2048) ║ 16 Bits ║ 01111110 ║
 * ╚══════════╩══════════╩═════════╩════════╩════════════════════╩═════════╩══════════╝
 *
 *  @author     Jérôme Skoda    <jerome.skoda@hotmail.fr>
 *  @version    1.7             (24/04/2015 - 30/04/2015)
 */
size_t PacketAX25::writeContent(uint8_t  *dst, const uint8_t *src, size_t src_len )
{
    size_t cursor= 0;

    // Write Header
    cursor+= writeHeader(&((uint8_t*)dst)[cursor]);

    // Write Information
    cursor+= writeInformation(&((uint8_t*)dst)[cursor], src, src_len);

    // Write CRC-16-CCITT of header and information field (no flags)
    // AX.25 protocol specified FCS field is LSB first
    uint16_t crc = crc16_ccitt(&((uint8_t*)dst)[1], cursor-1);
    ((uint8_t*)dst)[cursor]= tab_LSB_First[crc >> 8];
    cursor++;
    ((uint8_t*)dst)[cursor]= tab_LSB_First[crc & 0x00ff];
    cursor++;

    return cursor;
}


/**
 *  writeInformation
 *
 *  Write information/data field. AX.25 support 256 bytes maximum.
 *  In XCubeSat the maximum supported is 128 bytes.
 *
 *  @author     Jérôme Skoda    <jerome.skoda@hotmail.fr>
 *  @version    1.0             (27/04/2015)
 */
size_t PacketAX25::writeInformation(uint8_t  *dst, const uint8_t *src, size_t src_len )
{
    uint16_t length;

    // Write data
    for(length=0; (length < 128 && length < src_len) ; length++)
    {
        ((uint8_t*)dst)[length]= ((uint8_t*)src)[length];
    }

    return (size_t)length;
}


/**
 *  writePacket
 *
 *  Write frame format with AX25 protocol
 *  • Begin flags
 *  • Content bit stuffed
 *  • End flags
 * ╔══════════╦══════════╦═════════╦════════╦════════════════════╦═════════╦══════════╗
 * ║   Flag   ║ Address  ║ Control ║  PID   ║    Information     ║   FCS   ║   Flag   ║
 * ╠══════════╬══════════╬═════════╬════════╬════════════════════╬═════════╬══════════╣
 * ║ 01111110 ║ 112 Bits ║ 8 Bits  ║ 8 Bits ║ N*8 Bits (32-2048) ║ 16 Bits ║ 01111110 ║
 * ╚══════════╩══════════╩═════════╩════════╩════════════════════╩═════════╩══════════╝
 *
 *  @author     Jérôme Skoda    <jerome.skoda@hotmail.fr>
 *  @version    1.7             (24/04/2015 - 30/04/2015)
 */
void PacketAX25::writePacket (uint8_t *dst, sizeBitStuffing_t *dst_len, const uint8_t *src, size_t src_len)
{
    size_t cursor= 0;
    bool paddingLastByte= false;

    // Write flag in begin
    for(int i=0; i< N_FLAG_BEGIN; i++)
    {
        // Write Flag
        ((uint8_t*)dst)[cursor]= 0x7E;
        cursor++;
    }

    // Write content of AX.25 Packet bit stuffed
    bitStuffing(&((uint8_t*)dst)[cursor], dst_len, src, src_len);

    // Increment cursor (if the last octet is not complete then cursor pointed it)
    cursor+= dst_len->ByteSize - ((dst_len->LastBitLocation == 8)?0:1);

    // Write end flag
    uint8_t nFlag=0;
    while(nFlag < N_FLAG_END)
    {
        // Complete last data octet with flag
        if(dst_len->LastBitLocation != 8 && !paddingLastByte)
        {
            ((uint8_t*)dst)[cursor]|= 0x7E<<dst_len->LastBitLocation;
            paddingLastByte= true;
        }
        // Write end of flag
        else if( (dst_len->LastBitLocation != 8) && (nFlag == N_FLAG_BEGIN - 1))
        {
            ((uint8_t*)dst)[cursor]|= (0x7E>>dst_len->LastBitLocation);
            nFlag++;
        }
        // Complete last flag and begin new flag in current octet
        // If bit stuffing no create bit shifting(*) write complete flag
        // (*) dst_len.LastBitLocation == 8
        else
        {
            ((uint8_t*)dst)[cursor]= (0x7E7E>>dst_len->LastBitLocation)&0x00FF;
            nFlag++;
        }
        cursor++;
    }

    // Update data size
    dst_len->BitSize= 8*cursor - 8 + dst_len->LastBitLocation;
    dst_len->ByteSize= cursor;
}


/*EoF*/
